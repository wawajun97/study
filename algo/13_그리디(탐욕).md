그리디 :  최적 해를 구하는데 사용되는 근시안적인 방법?
- 최적화문제란 가능한 해들 중에서 가장 좋은 해를 찾는 문제  
- 머리 속에 떠오르는 생각을 검증 없이 바로 구현하면 그리디 접근이 된다.
- 한번 선택된 것은 번복하지 않는다 -> 다시 돌아갈 수 없다

ex) 손님에게 거스름돈을 주는 문제  
-> 손님에게 지폐와 동전의 개수를 최소한으로 주고싶다. 
-> 거스름돈 800원을 줘야할 때 만약 400원짜리가 있다면? -> 500 1개 + 100 3개가 아니라 400 2개가 최소이다.  

ex) 배낭 짐싸기(Knapsack)  
-> 물건들의 무게의 합이 W를 초과하지 않으면서 물건들의 값의 합이 최대가 되는 경우를 구하는 문제  
1. 0-1 knapsack : 배낭에 물건을 통째로 담아야 하는 문제(물건을 자를 수 없는 경우)  
- 값이 비싼 물건부터 담아보자. -> 최적이 아닐 수 있다. 25kg:15만원, 10kg:10만원, 10kg:9만원에서 25kg까지 가능할 때 10kg 두개가 최적
- 가벼운 물건부터 담아보자. -> 얘도 최적이 아닐 수 있다. 25kg:20만원, 10kg:10만원, 10kg:9만원에서 25kg까지 가능할 때 25kg 한개가 최적
- 무게 당 값이 높은 순서로 물건을 채운다. -> 얘도 안됨 -> Fractional Knapsack에서는 가능
=> 그리디 못씀..
  
2. Fractional Knapsack : 물건을 부분적으로 담는 것이 허용되는 문제(물건을 쪼갤 수 있는 경우)
- 무게 당 값이 높은 순서로 물건을 채운다.(정렬한다) -> 1. 5kg:50만원, 2. 10kg:60만원, 3. 20kg:140만원에서 30kg 채울 때 1(5kg) + 3(20kg) + 2의 절반(5kg) 담으면 최적

ex) 회의실 사용 분배(활동 선택 문제 - Activity Selection Problem)
- 시작시간과 종료시간이 있는 회의가 여러 개 있고 가능한 많은 회의를 하고 싶을 때 어떻게 배정해야 하는지에 대한 문제
- 종료시간이 빠른 회의 우선 -> 만약 종료 시간이 같다면 시작시간이 빠른 회의 우선
1. 종료 시간이 빠른 순서로 활동을 정렬
2. 첫번째 활동 선택
3. 선택한 활동의 종료시간보다 빠른 시작 시간을 가지는 활동은 무시하고 같거나 늦은 시작시간을 가진 활동 선택
4. 마지막까지 반복

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;

public class MeetingRoomTest {
	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    public static StringBuilder sb = new StringBuilder();
    
    public static class Meeting implements Comparable<Meeting> {
    	int start;
    	int end;
    	
		public Meeting(int start, int end) {
			super();
			this.start = start;
			this.end = end;
		}
		
		@Override
		public String toString() {
			return "Meeting [start=" + start + ", end=" + end + "]";
		}

		@Override
		public int compareTo(Meeting o) {
			//종료시간이 빠른게 우선
			int diff = Integer.compare(this.end, o.end);
			if(diff != 0) return diff;
			
			//종료시간이 같으면 시작시간이 빠른게 우선
			return Integer.compare(this.start, o.start);
		}
    }
    
	public static void main(String[] args) throws NumberFormatException, IOException {
		int N = Integer.parseInt(br.readLine());
		Meeting[] meetings = new Meeting[N];
		
		for(int i = 0;i< N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine(), " ");
			int s = Integer.parseInt(st.nextToken());
			int e = Integer.parseInt(st.nextToken());
			meetings[i] = new Meeting(s,e);
		}
		
		List<Meeting> result = getSchedule(meetings);
		System.out.println(result.size());
		
		for(Meeting meeting : result) {
			System.out.println(meeting);
		}
	}
	
	public static List<Meeting> getSchedule(Meeting[] meetings) {
		List<Meeting> list = new ArrayList<>();
		Arrays.sort(meetings);
		list.add(meetings[0]);

		//마지막 회의의 종료시간보다 시작시간이 큰 회의가 있으면 리스트에 추가
		for(int i = 1;i<meetings.length;i++) {
			if(list.get(list.size()-1).end <= meetings[i].start) {
				list.add(meetings[i]);
			}
		}
		return list;
	}

}

```

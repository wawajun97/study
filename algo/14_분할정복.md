분할정복 : 문제를 분할하여 문제를 해결하는 방법
- 일반적으로 재귀로 구현(항상 재귀는 아님 -> 일반 반복으로도 가능)

ex) 가짜동전 찾기
- 동전들 중 가짜 동전이 진짜보다 가벼울 때 양팔저울로 가짜 동전 찾는 방법
1. 반반 나눠서 무게를 잰다.
2. 더 가벼운 쪽만 다시 반으로 나눠서 잰다.
3. 가짜동전을 찾을 때까지 반복한다.

ex) 거듭제곱
- C^24 = C^12 * C^12
- C^12 = C^6 * C^6
- ...
- C^2 = C * C

```java
public static int func(int x, int n) {
    	if(n == 1) return x;
    	if(n % 2 == 0) { 
    		int y = func(x,n/2); // x^n/2 * x^n/2 = x^n;
    		return y * y;
    	} else { // 홀수일 때
    		int y = func(x,(n-1)/2);
    		return y * y * x; // x^(n-1)/2 * x^(n-1)/2 * x = x^n;
    	}
    }
``` 

ex) 같은 색 공간 만들기
- N * N 공간에서 사분할을 하고 한 영역에 모두 같은 색이 아니라면 또 사분할을 한다.
- 모두 같은 색이거나 더 이상 공간을 나눌 수 없을 때까지 반복
=> 실제로 자르는건 아니고 확인하고 싶은 정사각형의 좌상단의 좌표와 크기를 파라미터로 넘겨서 재귀호출

```java
public static void cut(int r, int c, int size) {		
		int sum = 0;
		for(int i = r;i<r+size;i++) {
			for(int j =c;j<c+size;j++) {
				sum += spaces[i][j]; //1이면 초록색 0이면 흰색
			}
		}
		
		if(sum == size * size) {
			++green;
		} else if(sum == 0) {
			++white;
		} else {
			int half = size/2;
			cut(r,c,half);
			cut(r,c + half,half);
			cut(r + half,c,half);
			cut(r + half,c + half,half);
		}
		
	}
```

이분탐색(이진탐색) : 정렬을 하여 구간을 반으로 쪼개면서 답을 찾는 기법 -> O(logN)
- 응용하여 Lower Bound & Upper Bound, 파라메트릭 서치 구현  
- Lower Bound : 값이 없어서 타겟보다 같거나 큰 값이 처음 나오는 위치를 응답 -> 목표값 이상의 값들 중 가장 작은 값의 인덱스
- Upper Bound : 값이 없어서 타겟보다 큰 값이 처음 나오는 위치를 응답 -> 목표 값 초과의 값들 중 가장 작은 값의 인덱스
- 파라메트릭 서치 : 최적화 문제를 yes or no로 변환하여 이진 탐색 기법을 활용하여 해결하는 방법  
                   이진 탐색과 다르게 주어진 일련의 값들이 아니라 주어진 범위 내에서 원하는 값 또는 원하는 조건을 만족하는 최적해를 찾을 때 사용

1. 자료의 중앙에 있는 원소를 고른다.
2. 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
3. 중앙 원소의 값과 찾고자 하는 목표 값이 일치하면 탐색을 끝낸다.
4. 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색하고, 크다면 오른쪽 반에 대해서 새로 검색을 수행한다.
5. 값을 찾을 때까지 반복한다.  
-> binarySearchTree에서 값을 못찾으면 가장 가까운 값의 인덱스에 - 붙여서 응답  

ex) 병뚜껑 숫자 맞추기
- 술래만 숫자를 확인하고 나머지 사람이 맞춘다.
- 한 사람이 숫자를 말하면 술래는 up down으로 힌트를 제시한다.


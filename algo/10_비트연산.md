비트 연산자
1. & : AND 연산 - 둘 다 1이면 1
2. | : OR 연산 - 둘 중 하나만 1이여도 1
3. ^ : XOR 연산 - 두 값이 다르면 1, 같으면 0
4. ~ : 모든 비트 반전(not) - 모두 반대로
5. << : 비트 열을 왼쪽으로 이동 - 뒤에 0 붙임(ex : 110 -> 1100) - 부호비트가 아닌 이상 두배씩 커짐
6. \>\> : 비트 열을 오른쪽으로 이동 - 마지막자리 자름(ex : 110 -> 11)

=> 비트마스킹 시 주로 사용
- 하나의 비트를 선택/비선택 등 양자택일을 저장 -> boolean배열도 가능한데 굳이? -> 비트마스킹이 메모리 효율이 더 좋다(boolean은 1바이트)
- 타겟에서 특정 비트의 값을 보고 싶을 때 1 << n 하여 타겟과 AND 연산을 하면 n번째 비트의 값이 나온다.
- 타겟에서 특정 비트의 값을 1로 세팅하고 싶을 때 1 << n 하여 타겟과 OR 연산을 하면 n번째 비트가 1로 세팅된다.

바이너리 카운팅을 통한 사전적 순서로 생성하는 방법
- 부분집합을 생성하기 위한 가장 자연스러운 방법
- 원소 수에 해당하는 N개의 비트열을 이용
- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다.

```java
int[] arr = {3,6,7,1,5,4};
		int n = arr.length;
		
		for(int i = 0;i<(1 << n);i++) {
			for(int j = 0;j<n;j++) {
				if((i & (1<<j)) != 0) {
					System.out.print(arr[j] + " ");
				}
			}
			System.out.println();
		}
```

BitSet class
- 내부적으로 long형 배열로 관리
-> 64개 이상의 big flag를 관리해야할 때 사용

1. 비트열을 나타내는 flag에서 특정 비트(i)의 상태만 반전(토글)하려면?
   - flag = ^= (1<<i) ( ex) i == 4이면 0001000 와 xor 연산)
2. 비트열을 나타내는 flag에서 특정 비트(i)의 상태만 0으로 만들려면? 
   - flag &= ~(1<<i) ( ex) i == 4이면 1110111과 and 연산)

swap(a,b)
a = a^b;
b = a^b;
a = a^b;

백트래킹 : 완전탐색인데 가지치기를 해서 경우의 수를 줄이는 방법 -> 끝까지 가도 안되는 경우는 더 이상 탐색 x
- 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 돌아가 다음 자식 노드로 간다.
- 유망하다 : 해답이 될 수 있다
- 가지치기 : 유망하지 않은 노드가 포함된 경로는 더 이상 고려하지 않는다.  

백트래킹 절차
1. 상태 공간 트리의 깊이 우선 탐색(DFS)을 실시한다.
2. 각 노드가 유망한지를 점검한다.
3. 그 노드가 유망하지 않다면 그 노드의 부모 노드로 돌아가서 다른 노드로의 검색을 계속한다.

백트래킹 vs DFS -> 백트래킹은 가지치기를 하고 DFS는 완전탐색을 한다.  

ex) N-Queen : 서로 위협하지 않도록 N개의 Queen을 배치하는 문제  
- 열이 같은지 확인하는 배열 : 크기가 N인 boolean배열을 생성하여 인덱스를 열로 생각하고 해당 열은 true
- 왼쪽 대각이 같은지 확인하는 배열 : 크기가 N*2인 boolean 배열을 생성하고 row + col 인덱스를 true
- 오른쪽 대각이 같은지 확인하는 배열 : 크기가 N*2인 boolean 배열을 생성하고 N + (row - col) 인덱스를 true
=> 세개 다 false이면 퀸을 놓을 수 있다.

```java
public class NQueenTest {
	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static int N,totalCnt;
	public static boolean[] col, slash,bSlash;
	public static void main(String[] args) throws NumberFormatException, IOException {
		N = Integer.parseInt(br.readLine());
		
		totalCnt = 0;
		
		col = new boolean[N+1]; // 열
		slash = new boolean[N*2 + 1]; // 왼쪽 대각선 /
		bSlash = new boolean[N*2 + 1]; // 오른쪽 대각선 \
	
		setQueen(1);
		
		System.out.println(totalCnt);
	}
	
	public static void setQueen(int row) {
		if(row == N+1) {
			totalCnt++;
			return;
		}
		
		for(int c =1;c<=N;c++) {
			// 열, 대각선을 확인해서 놓치 못하면 더 이상 탐색 x -> 가지치기
			if(col[c] || slash[c+row] || bSlash[N-(row-c)]) continue; 
			
			col[c] = slash[row+c] = bSlash[N-(row-c)] = true;
			setQueen(row+1);
			col[c] = slash[c+row] = bSlash[N-(row-c)] = false;
		}
	}

}
```

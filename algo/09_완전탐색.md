완전탐색 : 모든 경우의 수를 확인하는 기법
- 일반적으로 경우의 수가 상대적을 적을 때 사용 -> 시간복잡도 따져보고 가능하면 시도

순열과 조합
순열 : 서로 다른 n개 중 r개를 뽑는 경우의 수 -> nPr
- 순서가 의미가 있다

ex) 서로 다른 3개의 수에서 3자리 만드는 방법
- 첫번째 자리는 3가지 경우의 수 존재
- 두번째 자리는 첫번째 자리에서 뽑은 수 제외하고 뽑을 수 있기 때문에 2가지 경우의 수
- 세번째는 1가지 경우의 수
- 총 3 * 2 * 1 = 6가지 경우의 수
-> 재귀를 사용해서 풀이 가능

```java
public static void perm(int cnt) {
		if(cnt == 3) {
			//순열 생성 완료 -> 비즈니스 로직 처리
			return;
		}
		
		for(int i = 1;i<=3;i++) {
			if(isSelected[i]) continue;
			
			numbers[cnt] = i;
			isSelected[i] = true;
			perm(cnt+1);
			isSelected[i] = false;
		}
	}
```

중복순열 : 중복을 허용하는 순열
- 숫자를 사용했는지 체크할 필요가 없다 -> isSelected 불필요

```java
public static void dice(int depth) {
		if(depth == N) {
			// System.out.println(Arrays.toString(numbers));

			for(int i = 0;i<N;i++) {
				System.out.print(numbers[i] + " ");
			}
			System.out.println();
			totalCnt++;
			return;
		}
		
		for (int i = 1; i <= 6; i++) { //숫자 사용 체크 x
			numbers[depth] = i;
			dice(depth+1);
		}
	}
```

조합 : 서로 다른 n개 중 순서 무관하게 r개를 뽑는 경우의 수 -> nCr
- 순서가 의미가 없다

```java
public static void dice3(int depth, int cur) {
		if(depth == N) {
//			System.out.println(Arrays.toString(numbers));
			
			for(int i = 0;i<N;i++) {
				System.out.print(numbers[i] + " ");
			}
			System.out.println();
			totalCnt++;
			return;
		}
		
		for (int i = cur; i <= 6; i++) { //시작이 중요
			numbers[depth] = i;
			dice3(depth+1,i+1);
		}
	}
```

중복조합 : 중복을 허용하는 조합 -> nHr
- 중복을 허용하기 때문에 1 1 2를 뽑을 수 있지만 1 2 1과는 동일

```java
public static void dice3(int depth, int cur) {
		if(depth == N) {
//			System.out.println(Arrays.toString(numbers));
			
			for(int i = 0;i<N;i++) {
				System.out.print(numbers[i] + " ");
			}
			System.out.println();
			totalCnt++;
			return;
		}
		
		for (int i = cur; i <= 6; i++) {
			numbers[depth] = i;
			dice3(depth+1,i); //cur 파라미터를 +1 해주지 않으면 중복조합
		}
	}
```

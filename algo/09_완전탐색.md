완전탐색 : 모든 경우의 수를 확인하는 기법
- 일반적으로 경우의 수가 상대적을 적을 때 사용 -> 시간복잡도 따져보고 가능하면 시도

순열과 조합
순열 : 서로 다른 n개 중 r개를 뽑는 경우의 수 -> nPr
- 순서가 의미가 있다

ex) 서로 다른 3개의 수에서 3자리 만드는 방법
- 첫번째 자리는 3가지 경우의 수 존재
- 두번째 자리는 첫번째 자리에서 뽑은 수 제외하고 뽑을 수 있기 때문에 2가지 경우의 수
- 세번째는 1가지 경우의 수
- 총 3 * 2 * 1 = 6가지 경우의 수
-> 재귀를 사용해서 풀이 가능

```java
public static void perm(int cnt) {
		if(cnt == 3) {
			//순열 생성 완료 -> 비즈니스 로직 처리
			return;
		}
		
		for(int i = 1;i<=3;i++) {
			if(isSelected[i]) continue;
			
			numbers[cnt] = i;
			isSelected[i] = true;
			perm(cnt+1);
			isSelected[i] = false;
		}
	}
```

중복순열 : 중복을 허용하는 순열
- 숫자를 사용했는지 체크할 필요가 없다 -> isSelected 불필요

```java
public static void dice(int depth) {
		if(depth == N) {
			// System.out.println(Arrays.toString(numbers));

			for(int i = 0;i<N;i++) {
				System.out.print(numbers[i] + " ");
			}
			System.out.println();
			totalCnt++;
			return;
		}
		
		for (int i = 1; i <= 6; i++) { //숫자 사용 체크 x
			numbers[depth] = i;
			dice(depth+1);
		}
	}
```

조합 : 서로 다른 n개 중 순서 무관하게 r개를 뽑는 경우의 수 -> nCr
- 순서가 의미가 없다

```java
public static void dice3(int depth, int cur) {
		if(depth == N) {
//			System.out.println(Arrays.toString(numbers));
			
			for(int i = 0;i<N;i++) {
				System.out.print(numbers[i] + " ");
			}
			System.out.println();
			totalCnt++;
			return;
		}
		
		for (int i = cur; i <= 6; i++) { //시작이 중요
			numbers[depth] = i;
			dice3(depth+1,i+1);
		}
	}
```

중복조합 : 중복을 허용하는 조합 -> nHr
- 중복을 허용하기 때문에 1 1 2를 뽑을 수 있지만 1 2 1과는 동일

```java
public static void dice3(int depth, int cur) {
		if(depth == N) {
//			System.out.println(Arrays.toString(numbers));
			
			for(int i = 0;i<N;i++) {
				System.out.print(numbers[i] + " ");
			}
			System.out.println();
			totalCnt++;
			return;
		}
		
		for (int i = cur; i <= 6; i++) {
			numbers[depth] = i;
			dice3(depth+1,i); //cur 파라미터를 +1 해주지 않으면 중복조합
		}
	}
```

부분집합
-조합과 같다? -> 순서가 상관없기 때문
- 집합에 포함된 원소들을 선택하는 것 (ex : 배낭 짐싸기 - 최적의 부분집합을 찾는 것)

생성 방법
1. 반복문
```java
public static void makeSubSet() {
		int[] selected = new int[3];
		int[] arr = {1,2,3};
		
		for(int i = 1;i>=0;i--) { //1은 선택 0은 비선택
			selected[0] = i;
			for(int j = 1; j>=0;j--) {
				selected[1] = j;
				for(int k = 1; k>=0;k--) {
					selected[2] = k;
					for(int m = 0;m<3;m++) {
						if(selected[m] == 1) { //선택이 된 idx만 출력
							System.out.print(arr[m] + " ");
						}
					}
					System.out.println();
				}
			}
		}
	}
```

2. 재귀
```java
public static void makeSubSet(int idx) {
		if(idx == N) {
			for(int i = 0;i<N;i++) {
				if(isSelected[i]) {
					System.out.print(input[i] + " ");
				}
			}
			System.out.println();
			return;
		}
		
		//idx의 원소를 선택하는 경우
		isSelected[idx] = true;
		makeSubSet(idx+1);
		
		//idx의 원소를 선택하지 않는 경우
		isSelected[idx] = false;
		makeSubSet(idx+1);
	}
```

